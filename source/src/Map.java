/**
 * Map.java - Map class that holds and controls all aspects of the map
 * @author Group 10 - Pirates of the CoFo
 * @version 1.0.0
 * Map class as a part of CS-230 Assignment 2
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Scanner;
import javafx.animation.PauseTransition;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;
import javafx.scene.image.*;
import javafx.stage.StageStyle;
import javafx.util.Duration;
import twitter4j.TwitterException;


public class Map extends Application {

	private Stage primaryStage;

	private static final int WINDOW_WIDTH = 524;
	private static final int WINDOW_HEIGHT = 524;

	// The dimensions of the canvas
	private static final int CANVAS_WIDTH = 900;
	private static final int CANVAS_HEIGHT = 900;

	// The size of each cell
	private static int GRID_CELL_WIDTH = 75;
	private static int GRID_CELL_HEIGHT = 75;

	private Canvas canvas;

	// Cell images
	private Image doorBlue;
	private Image doorRed;
	private Image doorYellow;
	private Image doorToken1;
	private Image doorToken3;
	private Image doorToken5;
	private Image enemy1;
	private Image enemy1OnFloor;
	private Image enemy2;
	private Image enemy2OnFloor;
	private Image enemy3;
	private Image enemy3OnFloor;
	private Image enemy4;
	private Image enemy4OnFloor;
	private Image fire;
	private Image fireAmulet;
	private Image fireAmuletOnFloor;
	private Image floor;
	private Image goal;
	private Image keyBlue;
	private Image keyBlueOnFloor;
	private Image keyRed;
	private Image keyRedOnFloor;
	private Image keyYellow;
	private Image keyYellowOnFloor;
	private Image player;
	private Image playerOnFloor;
	private Image playerOnFire;
	private Image playerOnGoal;
	private Image playerOnWater;
	private Image teleporter;
	private Image token;
	private Image tokenOnFloor;
	private Image theVoid;
	private Image wall;
	private Image water;
	private Image waterAmulet;
	private Image waterAmuletOnFloor;

	// Entities
	private static Player thePlayer;
	private static StraightLineEnemy[] theStraightLineEnemies;
	private static DumbEnemy[] theDumbEnemies;
	private static WallFollowingEnemy[] theWallFollowingEnemies;
	private static SmartEnemy[] theSmartEnemies;

	private static Token[] tokens;
	private static Key[] keys;

	private Inventory playerInventory;
	private int[] mapSize;
	private static EnumIniInfo[][] theLevel;
	private int distanceToCenterX;
	private int distanceToCenterY;

	private String username;
	private int level;

	// Timer variables
	private long startTime = 0;
	private int finalTime = 0;
	private int savedTime = 0;

	boolean[][] movableTilesEnemy;
	boolean[][] movableTilesPlayer;
	boolean playerKilled = false;
	boolean playerFinished = false;

	private String filePath;


	/**
	 * Constructor for the Map class
	 * @param username Player's username
	 * @param level Level number
	 * @param filePath Level's file path
	 */
	public Map(String username, int level, String filePath) {
		this.username = username;
		this.level = level;
		this.filePath = filePath;
	}

	/**
	 * Read an level file and initialise the map.
	 * @param fileName The name of a level file.
	 */
	public static void setLevel( String fileName )
	{
		//`Analysis the level file.
		LvPreprocessor lp = new LvPreprocessor( fileName );
		int[] mapSize = lp.getMapSize();
		int width = mapSize[0];
		int height = mapSize[1];
		int enQua = lp.getMovEnQuan();
		//`Clear the arrays.
		theStraightLineEnemies = new StraightLineEnemy[0];
		theDumbEnemies = new DumbEnemy[0];
		theWallFollowingEnemies = new WallFollowingEnemy[0];
		theSmartEnemies = new SmartEnemy[0];
		tokens = new Token[0];
		keys = new Key[0];
		theLevel = new EnumIniInfo[width][height];
		//`Initialise the grid.
		for ( int y = 0; y < height; ++y ) {
			for ( int x = 0; x < width; ++x ) {
				IniInfo[] tileInfo = lp.getTileInfo( x, y );
				initialiseTile( x, y, tileInfo );
			}
		}
		//`Initialise the Moveable entities.
		for ( int i = 0; i < enQua; ++i ) {
			IniInfo[] enInfo = lp.getMovEnInfo( i );
			addMovEnt( enInfo );
		}

	}

	/**
	 * Initialise a tile with a coordinate and an initial info generated by a file reader
	 * @param x x coordinate of the tile
	 * @param y y coordinate of the tile
	 * @param tileInfo A tile's info
	 */
	private static void initialiseTile( int x, int y, IniInfo[] tileInfo )
	{
		switch ( tileInfo[0].asEnum() ) {
			case KEY: //<<< Key case.
				EnumIniInfo colour = tileInfo[3].asEnum();
				Key[] oldKeys = keys;
				keys = new Key[ oldKeys.length + 1 ];
				extendArray( oldKeys, new Key( x, y, colour ), keys );
				theLevel[x][y] = tileInfo[0].asEnum();
				switch ( colour ) {
					case RED:
						theLevel[x][y] = EnumIniInfo.RED_KEY;
						break;
					case GREEN:
						theLevel[x][y] = EnumIniInfo.GREEN_KEY;
						break;
					case BLUE:
						theLevel[x][y] = EnumIniInfo.BLUE_KEY;
						break;
					case YELLOW:
						theLevel[x][y] = EnumIniInfo.YELLOW_KEY;
						break;
				}
				break;
			case TOKEN: //<<< Token case
				Token[] oldTokens = tokens;
				tokens = new Token[ oldTokens.length + 1 ];
				extendArray( oldTokens, new Token( x, y ), tokens );
				theLevel[x][y] = tileInfo[0].asEnum();
				break;
			case COLOUR_DOOR: //<<< Colour door case
				switch ( tileInfo[3].asEnum() ) {
					case RED:
						theLevel[x][y] = EnumIniInfo.RED_DOOR;
						break;
					case BLUE:
						theLevel[x][y] = EnumIniInfo.BLUE_DOOR;
						break;
					case YELLOW:
						theLevel[x][y] = EnumIniInfo.YELLOW_DOOR;
						break;
				}
				break;
			case TOKEN_DOOR: //<<< Token door case
				switch ( tileInfo[3].asInt() ) {
					case 1:
						theLevel[x][y] = EnumIniInfo.TOKEN_DOOR_1;
						break;
					case 3:
						theLevel[x][y] = EnumIniInfo.TOKEN_DOOR_3;
						break;
					case 5:
						theLevel[x][y] = EnumIniInfo.TOKEN_DOOR_5;
						break;
				}
				break;
			case TELEPORTER: //<<< Teleporter case
				//TODO
				theLevel[x][y] = tileInfo[0].asEnum();
				break;
			default:
				theLevel[x][y] = tileInfo[0].asEnum();
		}
	}

	/**
	 * Initialise a moveable entity and add it into one of the Enemy arrays or
	 * just initialise this.thePlayer if it is the player.
	 * @param enInfo The initial info required to initialise the entity.
	 */
	private static void addMovEnt( IniInfo[] enInfo )
	{
		EnumIniInfo enType = enInfo[0].asEnum();
		int x = enInfo[1].asInt();
		int y = enInfo[2].asInt();
		switch ( enType ) {
			case PLAYER:
				thePlayer = new Player( x, y);
				break;
			case STRAIGHT_LINE_ENEMY:
				EnumIniInfo direc = enInfo[3].asEnum();
				StraightLineEnemy sle = new StraightLineEnemy( x, y, 0, -1 );
				switch ( direc ) {
					case UP:
						sle = new StraightLineEnemy( x, y, 0, -1 );
						break;
					case DOWN:
						sle = new StraightLineEnemy( x, y, 0, 1 );
						break;
					case LEFT:
						sle = new StraightLineEnemy( x, y, -1, 0 );
						break;
					case RIGHT:
						sle = new StraightLineEnemy( x, y, 1, 0 );
						break;
				}
				StraightLineEnemy[] sles = theStraightLineEnemies;
				theStraightLineEnemies =
						new StraightLineEnemy[ sles.length + 1 ];
				extendArray( sles, sle, theStraightLineEnemies );
				break;
			case WALL_FOLLOWING_ENEMY:
				WallFollowingEnemy wfe = new WallFollowingEnemy( x, y );
				WallFollowingEnemy[] wfes = theWallFollowingEnemies;
				theWallFollowingEnemies =
						new WallFollowingEnemy[ wfes.length + 1 ];
				extendArray( wfes, wfe, theWallFollowingEnemies );
				break;
			case DUMB_TARGETING_ENEMY:
				DumbEnemy dte = new DumbEnemy( x, y );
				DumbEnemy[] dtes = theDumbEnemies;
				theDumbEnemies = new DumbEnemy[ dtes.length + 1 ];
				extendArray( dtes, dte, theDumbEnemies );
				break;
			case SMART_TARGETING_ENEMY:
				SmartEnemy ste = new SmartEnemy( x, y );
				SmartEnemy[] stes = theSmartEnemies;
				theSmartEnemies = new SmartEnemy[ stes.length + 1 ];
				extendArray( stes, ste, theSmartEnemies );
				break;
		}
	}

	/**
	 * Add an element at the end of an array.
	 * @param array The original array
	 * @param elem The element
	 * @param result An array with one more element than the orignial array.
	 */
	private static <E> void extendArray( E[] array, E elem, E[] result )
	{
		for ( int i = 0; i < array.length; ++i ) {
			result[i] = array[i];
		}
		result[ array.length ] = elem;
	}

	/**
	 * Sets the cell graphics
	 * @throws FileNotFoundException
	 */
	public void setsAllTheGraphics() throws FileNotFoundException{

		// Image file paths
		doorBlue = new Image("doorBlue.png");
		doorRed = new Image("doorRed.png");
		doorYellow = new Image("doorYellow.png");
		doorToken1 = new Image("doorToken-1.png");
		doorToken3 = new Image("doorToken-3.png");
		doorToken5 = new Image("doorToken-5.png");
		enemy1 = new Image("enemy1.png");
		enemy1OnFloor = new Image("enemy1OnFloor.png");
		enemy2 = new Image("enemy2.png");
		enemy2OnFloor = new Image("enemy2OnFloor.png");
		enemy3 = new Image("enemy3.png");
		enemy3OnFloor = new Image("enemy3OnFloor.png");;
		enemy4 = new Image("enemy4.png");
		enemy4OnFloor = new Image("enemy4OnFloor.png");
		fire = new Image("fire.png");
		fireAmulet = new Image("fireAmulet.png");
		fireAmuletOnFloor = new Image("fireAmuletOnFloor.png");
		floor = new Image("floor.png");
		goal = new Image("goal.png");
		keyBlue = new Image("keyBlue.png");
		keyBlueOnFloor = new Image("keyBlueOnFloor.png");
		keyRed = new Image("keyRed.png");;
		keyRedOnFloor = new Image("keyRedOnFloor.png");
		keyYellow = new Image("keyYellow.png");
		keyYellowOnFloor = new Image("keyYellowOnFloor.png");
		player = new Image("player.png");
		playerOnFloor = new Image("playerOnFloor.png");
		playerOnFire = new Image("playerOnFire.png");
		playerOnGoal = new Image("playerOnGoal.png");
		playerOnWater = new Image("playerOnWater.png");
		teleporter = new Image("teleporter.png");
		token = new Image("token.png");
		tokenOnFloor = new Image("tokenOnFloor.png");
		theVoid = new Image("Void.png");
		wall = new Image("wall.png");
		water = new Image("water.png");
		waterAmulet = new Image("waterAmulet.png");
		waterAmuletOnFloor = new Image("waterAmuletOnFloor.png");
	}

	/**
	 * Calculates what tiles can be moved onto
	 */
	public void calculatesMovableTilesPlayer(){
		int x = theLevel.length;
		int y = theLevel[0].length;

		//Draws tiles
		for(int j = 0; j < y; j++){
			for(int i = 0; i < x; i++){
				switch(theLevel[i][j]){
					case FLOOR:
						movableTilesPlayer[i][j] = true;
						break;
					case WALL:
						movableTilesPlayer[i][j] = false;
						break;
					case VOID_CELL :
						movableTilesPlayer[i][j] = false;
						break;
					case TOKEN :
						movableTilesPlayer[i][j] = true;
						break;
					case LAVA :
						movableTilesPlayer[i][j] = true;
						break;
					case WATER :
						movableTilesPlayer[i][j] = true;
						break;
					case WATER_BOOTS :
						movableTilesPlayer[i][j] = true;
						break;
					case FIRE_BOOTS :
						movableTilesPlayer[i][j] = true;
						break;
					case FINISH :
						movableTilesPlayer[i][j] = true;
						break;
					case RED_DOOR :
						if(playerInventory.isMovableKeys("red") == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case BLUE_DOOR :
						if(playerInventory.isMovableKeys("blue") == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case YELLOW_DOOR :
						if(playerInventory.isMovableKeys("yellow") == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case RED_KEY :
						movableTilesPlayer[i][j] = true;
						break;
					case BLUE_KEY :
						movableTilesPlayer[i][j] = true;
						break;
					case YELLOW_KEY :
						movableTilesPlayer[i][j] = true;
						break;
					case TOKEN_DOOR_1 :
						if(playerInventory.isMovableTokens(1) == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case TOKEN_DOOR_3 :
						if(playerInventory.isMovableTokens(3) == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case TOKEN_DOOR_5 :
						if(playerInventory.isMovableTokens(5) == true){
							movableTilesPlayer[i][j] = true;
						}else{
							movableTilesPlayer[i][j] = false;
						}
						break;
					case TELEPORTER :
						movableTilesPlayer[i][j] = true;
						break;
					default:
						movableTilesPlayer[i][j] = false;
						break;//do nothing (shouldn't reach this anyways. Otherwise issue with the level file, that should be caught in file reader)
				}
			}
		}

	}
	/**
	 * Calculates if an enemy can move onto a cell
	 */
	public void calculatesMovableTilesEnemy(){
		int x = theLevel.length;
		int y = theLevel[0].length;

		for(int j = 0; j < y; j++){
			for(int i = 0; i < x; i++){
				switch(theLevel[i][j]){
					case FLOOR :
						movableTilesEnemy[i][j] = true;
						break;
					default :
						movableTilesEnemy[i][j] = false;
						break;
				}
			}
		}
	}

	public void start(Stage primaryStage){
		// Build the GUI
		Pane root = buildGUI();

		// Create a scene from the GUI
		Scene scene = new Scene(root, WINDOW_WIDTH, WINDOW_HEIGHT);
		setLevel(this.filePath);
		int x = theLevel.length;
		int y = theLevel[0].length;
		distanceToCenterX = -thePlayer.getXPosition() + 3;
		distanceToCenterY = -thePlayer.getYPosition() + 3;
		movableTilesPlayer = new boolean[x][y];
		movableTilesEnemy = new boolean[x][y];
		playerInventory = new Inventory();
		getDataFromFile();
		playerKilled = false;
		playerFinished = false;
		calculatesMovableTilesPlayer();
		calculatesMovableTilesEnemy();
		try {
			setsAllTheGraphics();
		} catch (FileNotFoundException e) {
			System.out.print("Image files need to be in the bin folder");
			e.printStackTrace();
		}

		// Register an event handler for key presses
		scene.addEventFilter(KeyEvent.KEY_PRESSED, event -> processKeyPressed(event));

		// Display the scene on the stage
		drawGame();
		this.primaryStage = primaryStage;
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	public void processKeyPressed(KeyEvent event){
		//Move player. Check if can move (because of doors).
		switch (event.getCode()) {
			case RIGHT:
				// Right key was pressed. So move the player right by one cell.
				if (thePlayer.validMove(movableTilesPlayer, 1, 0)){
					thePlayer.moveRight();
					distanceToCenterX--;
					if(theLevel[thePlayer.xPosition][thePlayer.yPosition] == EnumIniInfo.TELEPORTER){
						int[] tempArray = findTeleporterNotOn(thePlayer.xPosition, thePlayer.yPosition);

						if(thePlayer.validMoveCoordinates(movableTilesPlayer, tempArray[0] + 1, tempArray[1])){
							//can move so teleport
							thePlayer.xPosition = tempArray[0] + 1;
							thePlayer.yPosition = tempArray[1];
							distanceToCenterX = distanceToCenterX - tempArray[2];
							distanceToCenterX--;
							distanceToCenterY = distanceToCenterY + tempArray[3];
						}else{
							//can't move
							//move back off teleporter
							thePlayer.moveLeft();
							distanceToCenterX++;
						}

					}
				}

				break;
			case LEFT:
				if (thePlayer.validMove(movableTilesPlayer, -1, 0)){
					thePlayer.moveLeft();
					distanceToCenterX++;
					if(theLevel[thePlayer.xPosition][thePlayer.yPosition] == EnumIniInfo.TELEPORTER){
						int[] tempArray = findTeleporterNotOn(thePlayer.xPosition, thePlayer.yPosition);

						if(thePlayer.validMoveCoordinates(movableTilesPlayer, tempArray[0] - 1, tempArray[1])){
							//can move so teleport
							thePlayer.xPosition = tempArray[0] - 1;
							thePlayer.yPosition = tempArray[1];
							distanceToCenterX = distanceToCenterX - tempArray[2];
							distanceToCenterX++;
							distanceToCenterY = distanceToCenterY + tempArray[3];
						}else{
							//can't move
							//move back off teleporter
							thePlayer.moveRight();
							distanceToCenterX--;
						}
					}
				}
				break;
			case UP:
				if (thePlayer.validMove(movableTilesPlayer, 0, -1)){
					thePlayer.moveUp();
					distanceToCenterY++;
					if(theLevel[thePlayer.xPosition][thePlayer.yPosition] == EnumIniInfo.TELEPORTER){
						int[] tempArray = findTeleporterNotOn(thePlayer.xPosition, thePlayer.yPosition);

						if(thePlayer.validMoveCoordinates(movableTilesPlayer, tempArray[0], tempArray[1] - 1)){
							//can move so teleport
							thePlayer.xPosition = tempArray[0];
							thePlayer.yPosition = tempArray[1] - 1;
							distanceToCenterX = distanceToCenterX - tempArray[2];
							distanceToCenterY = distanceToCenterY + tempArray[3];
							distanceToCenterY++;
						}else{
							//can't move
							//move back off teleporter
							thePlayer.moveDown();
							distanceToCenterY--;
						}

					}
				}
				break;
			case DOWN:
				if (thePlayer.validMove(movableTilesPlayer, 0, 1)){
					thePlayer.moveDown();
					distanceToCenterY--;
					if(theLevel[thePlayer.xPosition][thePlayer.yPosition] == EnumIniInfo.TELEPORTER){
						int[] tempArray = findTeleporterNotOn(thePlayer.xPosition, thePlayer.yPosition);

						if(thePlayer.validMoveCoordinates(movableTilesPlayer, tempArray[0], tempArray[1] + 1)){
							//can move so teleport
							thePlayer.xPosition = tempArray[0];
							thePlayer.yPosition = tempArray[1] + 1;
							distanceToCenterX = distanceToCenterX - tempArray[2];
							distanceToCenterY = distanceToCenterY + tempArray[3];
							distanceToCenterY--;
						}else{
							//can't move
							//move back off teleporter
							thePlayer.moveUp();
							distanceToCenterY++;
						}
					}
				}
				break;
			default:
				// Do nothing
				break;
		}

		//Then call the playerHasMovedNowDoRestOfTurn method.
		playerHasMovedNowDoRestOfTurn();
		drawGame();
		event.consume();
	}

	/**
	 * Find where teleporters are not
	 * @param xPos X coordinate
	 * @param yPos Y coordinate
	 * @return xyPosition
	 */
	public int[] findTeleporterNotOn(int xPos, int yPos) {
		int k = theLevel.length;
		int l = theLevel[0].length;

		for(int j = 0; j < l; j++){
			for(int i = 0; i < k; i++){
				switch(theLevel[i][j]){
					case TELEPORTER :
						if(i == xPos && j == yPos) {	//playerX, playerY making sure not TP standing on

						} else{
							int[] xyPosition = {i,j,i - xPos,j - yPos};
							return xyPosition;
						}
						break;
					default :
						break;
				}
			}
		}
		return null;
	}

	public void playerHasMovedNowDoRestOfTurn() {
		switch(theLevel[thePlayer.xPosition][thePlayer.yPosition]){
			case TOKEN :
				playerInventory.addTokens();
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case WATER_BOOTS :
				playerInventory.addFlippers();
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case FIRE_BOOTS :
				playerInventory.addFireBoots();
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case RED_KEY :
				playerInventory.addKey("red");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case BLUE_KEY :
				playerInventory.addKey("blue");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case YELLOW_KEY :
				playerInventory.addKey("yellow");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case RED_DOOR :
				playerInventory.useKey("red");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case BLUE_DOOR :
				playerInventory.useKey("blue");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case YELLOW_DOOR :
				playerInventory.useKey("yellow");
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				break;
			case TOKEN_DOOR_1 :
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				playerInventory.delTokens(1);
				break;
			case TOKEN_DOOR_3 :
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				playerInventory.delTokens(3);
				break;
			case TOKEN_DOOR_5 :
				theLevel[thePlayer.xPosition][thePlayer.yPosition] = EnumIniInfo.FLOOR;
				playerInventory.delTokens(5);
				break;
			case FINISH :
				playerFinished = true;
				break;
			default :
				break;
		}

		calculatesMovableTilesEnemy();
		calculatesMovableTilesPlayer();
		updateEnemies();
		if(playerKilled){
			killPlayer();
		}
		if(playerFinished) {
			finish();
		}

	}

	/**
	 * Updates enemies
	 */
	public void updateEnemies(){
		//CHANGES STRAIGHT LINE ENEMIES LOCATION AND CHECKS IF KILLS PLAYER
		for(int i = 0; i < theStraightLineEnemies.length; i++){
			if (theStraightLineEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
			theStraightLineEnemies[i].calculateNextMove(movableTilesEnemy);
			if (theStraightLineEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
		}

		//CHANGES DUMB ENEMIES LOCATION AND CHECKS IF KILLS PLAYER
		for(int i = 0; i < theDumbEnemies.length; i++) {
			if (theDumbEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
			theDumbEnemies[i].calculateNextMove(movableTilesEnemy, thePlayer);
			if (theDumbEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
		}

		//CHANGES WALL FOLLOWING ENEMIES LOCATION AND CHECKS IF KILLS PLAYER
		for(int i = 0; i < theWallFollowingEnemies.length; i++) {
			if (theWallFollowingEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
			theWallFollowingEnemies[i].calculateNextMove(movableTilesEnemy);
			if (theWallFollowingEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
		}
		//CHANGES SMART ENEMIES LOCATION AND CHECKS IF KILLS PLAYER
		for(int i = 0; i < theSmartEnemies.length; i++){
			if (theSmartEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
			theSmartEnemies[i].calculateNextMove(movableTilesEnemy, thePlayer);
			if (theSmartEnemies[i].checkKillPlayer(thePlayer, theLevel)){
				playerKilled = true;
			}
		}
	}

	/**
	 * Draws the game
	 */
	public void drawGame(){
		GraphicsContext gc = canvas.getGraphicsContext2D();
		gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
		int x = theLevel.length;
		int y = theLevel[0].length;

		//Draws tiles
		for(int j = (-3 + thePlayer.yPosition); j <= (thePlayer.yPosition + 3); j++){
			for(int i =(-3 + thePlayer.xPosition); i <= (thePlayer.xPosition + 3); i++){
				switch(theLevel[i][j]){
					case FLOOR:
						gc.drawImage(calculateWhichFloorImage(i,j), (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case WALL:
						gc.drawImage(wall, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case VOID_CELL :
						gc.drawImage(theVoid, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case TOKEN :
						gc.drawImage(tokenOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case LAVA :
						gc.drawImage(calculateWhichLavaImage(i,j), (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case WATER :
						gc.drawImage(calculateWhichWaterImage(i,j), (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case WATER_BOOTS :
						gc.drawImage(waterAmuletOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case FIRE_BOOTS :
						gc.drawImage(fireAmuletOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case FINISH :
						gc.drawImage(calculateWhichFinishImage(i,j), (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case RED_DOOR :
						gc.drawImage(doorRed, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case BLUE_DOOR :
						gc.drawImage(doorBlue, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case YELLOW_DOOR :
						gc.drawImage(doorYellow, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case RED_KEY :
						gc.drawImage(keyRedOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case BLUE_KEY :
						gc.drawImage(keyBlueOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case YELLOW_KEY :
						gc.drawImage(keyYellowOnFloor, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case TOKEN_DOOR_1 :
						gc.drawImage(doorToken1, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case TOKEN_DOOR_3 :
						gc.drawImage(doorToken3, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case TOKEN_DOOR_5 :
						gc.drawImage(doorToken5, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					case TELEPORTER :
						gc.drawImage(teleporter, (i + distanceToCenterX)*GRID_CELL_WIDTH, (j + distanceToCenterY)*GRID_CELL_HEIGHT, GRID_CELL_WIDTH, GRID_CELL_HEIGHT);
						break;
					default:
						break;//do nothing (shouldn't reach this anyways. Otherwise issue with the level file, that should be caught in file reader)
				}
			}

		}
	}

	/**
	 * Decides what water image to use
	 * @param i X coordinate
	 * @param j Y coordinate
	 * @return Water image
	 */
	public Image calculateWhichWaterImage(int i, int j){
		if(thePlayer.xPosition == i && thePlayer.yPosition == j && !playerInventory.isMovableFlippers()) {
			playerKilled = true;
			return playerOnWater;
		} else if(thePlayer.xPosition == i && thePlayer.yPosition == j && playerInventory.isMovableFlippers())	{
			return playerOnWater;
		} else {
			return water;
		}
	}

	/**
	 * Decides what fire image to use
	 * @param i X coordinate
	 * @param j Y coordinate
	 * @return Fire image
	 */
	public Image calculateWhichLavaImage(int i, int j){
		if(thePlayer.xPosition == i && thePlayer.yPosition == j && !playerInventory.isMovableFireBoots()) {
			playerKilled = true;
			return playerOnFire;
		} else if(thePlayer.xPosition == i && thePlayer.yPosition == j && playerInventory.isMovableFireBoots()) {
			return playerOnFire;
		} else {
			return fire;
		}
	}

	/**
	 * Decides what finish image to use
	 * @param i X coordinate
	 * @param j Y coordinate
	 * @return Finish image
	 */
	public Image calculateWhichFinishImage(int i, int j){
		if(thePlayer.xPosition == i && thePlayer.yPosition == j){
			playerFinished = true;
			return playerOnGoal;
		}else{
			return goal;
		}

	}

	/**
	 * Decides which floor image to use
	 * @param xCoordinate The X coordinate
	 * @param yCoordinate The Y coordinate
	 * @return Floor image
	 */
	public Image calculateWhichFloorImage(int xCoordinate, int yCoordinate){
		if(thePlayer.xPosition == xCoordinate && thePlayer.yPosition == yCoordinate && playerKilled == false){
			return playerOnFloor;
		}
		for(int i = 0; i < theStraightLineEnemies.length; i++){
			if(theStraightLineEnemies[i].xPosition == xCoordinate && theStraightLineEnemies[i].yPosition == yCoordinate){
				return enemy1OnFloor;
			}
		}
		for(int j = 0; j < theWallFollowingEnemies.length; j++){
			if(theWallFollowingEnemies[j].xPosition == xCoordinate && theWallFollowingEnemies[j].yPosition == yCoordinate){
				return enemy2OnFloor;
			}
		}
		for(int k = 0; k < theDumbEnemies.length; k++){
			if(theDumbEnemies[k].xPosition == xCoordinate && theDumbEnemies[k].yPosition == yCoordinate){
				return enemy3OnFloor;
			}
		}
		for(int j = 0; j < theSmartEnemies.length; j++){
			if(theSmartEnemies[j].xPosition == xCoordinate && theSmartEnemies[j].yPosition == yCoordinate){
				return enemy4OnFloor;
			}
		}

		return floor;
	}

	/**
	 * Restarts the game map
	 */
	public void restartGame(){
		Stage newStage = new Stage();
		Map m = new Map(this.username, this.level, this.filePath);
		m.start(newStage);
	}

	/**
	 * Creates the GUI
	 * @return
	 */
	private Pane buildGUI() {
		// Create top-level panel that will hold all GUI
		canvas = new Canvas(CANVAS_WIDTH, CANVAS_HEIGHT);
		AnchorPane root = new AnchorPane(canvas);

		Button btnSave = new Button();
		btnSave.setText("Save");

		AnchorPane.setLeftAnchor(btnSave, 0.0);
		root.getChildren().add(btnSave);

		btnSave.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				save();
			}
		});

		startTime = System.currentTimeMillis();
		return root;
	}

	/**
	 * Loads the next game
	 */
	public void nextGame(){
		if(this.level < 5) {
			Stage newMapStage = new Stage();
			this.level++;
			int newLevel = this.level;
			Map newMap = new Map(this.username, newLevel, "./bin/Level_" + this.level + ".txt");
			newMap.start(newMapStage);
		} else {
			showMainMenu(this.username);
		}
		this.primaryStage.close();
	}

	/**
	 * Displays the main menu and carries the username into the main menu
	 * @param username The username to be passed into main menu
	 * @return The main menu stage
	 */
	public Stage showMainMenu(String username) {
		FXMLLoader loader =  new FXMLLoader(
				getClass().getResource("mainMenu.fxml")
		);
		Stage stage = new Stage(StageStyle.DECORATED);

		try {
			stage.setScene(new Scene((Pane) loader.load()));
		} catch (IOException e) {
			e.printStackTrace();
		}

		MainMenu controller = loader.<MainMenu>getController();
		controller.setLabel(username);

		stage.show();

		return stage;
	}

	/**
	 * Kills the player
	 */
	public void killPlayer() {
		try {

			// Create death notification popup
			Pane popup = (Pane)FXMLLoader.load(getClass().getResource("deathScreen.fxml"));
			Scene death = new Scene(popup, 250, 250);
			Stage deathStage = new Stage();

			// Show the popup
			deathStage.initStyle(StageStyle.UNDECORATED);
			deathStage.setScene(death);
			deathStage.show();
			this.primaryStage.close();

			PauseTransition pause = new PauseTransition(Duration.seconds(3));
			pause.setOnFinished(e -> {
				deathStage.hide();
				restartGame();
			});
			pause.play();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Completes the game, checking if a highscore was made, and loads next level if possible
	 */
	public void finish() {
		finalTime = (int) ((System.currentTimeMillis() - startTime)/1000);
		Profile p = new Profile();

		if(finalTime < p.getHighscore(this.username, this.level)) {
			Tweet tweet = new Tweet();
			try {
				tweet.tweetSetup(username, finalTime, this.level);
			} catch (TwitterException e) {
				e.printStackTrace();
			}
			p.changeHighscore(this.username, this.level, this.finalTime);
		}

		if(this.level + 1 > p.getLevelFromFile(this.username) && !(this.level > 4)) {
			p.setLevel(this.username, this.level + 1);
		}
			File file = new File("./bin/" + this.username + "0.txt");
			file.delete();
			file = new File("./bin/" + this.username + "0_Inv.txt");
			file.delete();

		try {

			// Create death notification popup
			Pane popup = (Pane) FXMLLoader.load(getClass().getResource("completeScreen.fxml"));
			Scene complete = new Scene(popup, 500, 310);
			Stage completeStage = new Stage();

			// Show the popup
			completeStage.initStyle(StageStyle.UNDECORATED);
			completeStage.setScene(complete);

			PauseTransition pauseMain = new PauseTransition(Duration.seconds(1));
			pauseMain.setOnFinished(e -> {
				this.primaryStage.close();
				completeStage.show();


			});
			pauseMain.play();

			PauseTransition pauseSecondary = new PauseTransition(Duration.seconds(3));
			pauseSecondary.setOnFinished(e -> {
				completeStage.hide();
				nextGame();
			});
			pauseSecondary.play();
		} catch(Exception e) {
			e.printStackTrace();
		}

	}

	/**
	 * Saves the game
	 */
	public void save() {
		Save s = new Save(this.theLevel, this.username, this.level, this.thePlayer, this.theStraightLineEnemies,
				this.theWallFollowingEnemies, this.theDumbEnemies, this.theSmartEnemies, this.playerInventory,
				(int)(((System.currentTimeMillis() - startTime)/1000) + savedTime));
		s.save();
		this.primaryStage.close();
		showMainMenu(this.username);
	}

	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Loads the saved level file
	 */
	public void getDataFromFile() {
		Scanner in = null;
		File file = new File("./bin/" + this.username + "0_Inv.txt");
		int count;
		String item;

		if(file.exists()) {
			try {
				in = new Scanner(file);
			}
			catch (FileNotFoundException e) {
				System.out.println("Profile source file not found in game files: \n");
				System.out.println("Suggested fix - Redownload game files.");
			}
			in.useDelimiter(",");

			while(in.hasNext()) {
				item = in.next();
				if(item.equals("Item_Red")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addKey("red");
					}
				}

				if(item.equals("Item_Blue")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addKey("blue");
					}
				}

				if(item.equals("Item_Yellow")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addKey("yellow");
					}
				}

				if(item.equals("Item_Tokens")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addTokens();
					}
				}

				if(item.equals("Item_FireBoots")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addFireBoots();
					}
				}

				if(item.equals("Item_Flippers")) {
					count = in.nextInt();
					for(int i = 0; i < count; i++) {
						playerInventory.addFlippers();
					}
				}

				if(item.equals("Time")) {
					this.savedTime = in.nextInt();
				}

				if(item.equals("Level")) {
					this.level = in.nextInt();
				}
				in.nextLine();
			}
		}

	}
}